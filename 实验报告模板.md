# 《数据库系统实践》实验报告（模板 + 参考实现说明）

> 适用项目：多数据库（MySQL / PostgreSQL / SQL Server）在线同步与冲突检测平台  
> 仓库目录：`dbsync_platform_starter`  
> 说明：本模板包含“可直接填写的实验报告结构”+“基于当前代码的后端逻辑详解”。你可以在填写区按需删减。

---

## 0. 封面信息（填写）

- 课程名称：数据库系统实践
- 实验题目：多数据库实时/定时同步与冲突检测平台
- 学号/姓名：__________
- 指导老师：__________
- 完成日期：____年__月__日
- Git 仓库地址：__________
- 演示地址（如有）：__________

---

## 1. 实验目的（参考任务书，可按需改写）

本次实践目标为：运用数据库课程的基础理论知识与工程实践能力，设计并实现一套满足功能需求、结构合理、安全稳定、易用可演示的系统。重点体现：

1) 数据库对象设计与 SQL 能力（表/约束/索引/视图/复杂 SQL）。  
2) 数据库端编程能力（触发器/函数/过程等，完成自动化逻辑）。  
3) Docker 部署与系统工程能力（前后端接口、容器化、可视化、第三方接口）。  
4) 冲突检测与管理员处理闭环（邮件提醒、移动端/PC 访问、处理与回写）。  

---

## 2. 需求分析（对照任务书逐条说明）

### 2.1 需求清单与实现映射（建议用表格）

| 任务书条目 | 需求描述 | 本系统实现方式 | 证据（页面/接口/脚本） |
|---|---|---|---|
| 1 | ≥3 种数据库 | MySQL / PostgreSQL / SQL Server 三库 | `docker-compose.yml` |
| 2 | 三库表结构一致 | 三套建表脚本保持一致 | `db/mysql|postgres|mssql/01_schema.sql` |
| 3 | ≥5 张表 | users/customers/products/orders/order_items | 同上 |
| 4 | 用户管理与权限 | JWT 登录；注册需注册码；admin 才可处理冲突 | `backend/app/auth.py`、`backend/app/main.py` |
| 5 | 复杂 SQL 查询页面 + 优化 | Top customers（多表 JOIN + 聚合 + 子查询）+ 索引优化 | `/ui/query`、`idx_*` |
| 6 | 同步保持一致 | 触发器写 change_log；worker 复制到其它库 | `change_log`、`worker.py`、`replicator.py` |
| 7 | 实时 + 定时同步 | worker 支持 realtime/schedule/hybrid | `.env`、`worker.py` |
| 8 | 冲突邮件提醒 | 冲突写入 conflicts 后发送邮件 | `emailer.py`、MailHog |
| 9 | 邮件链接带认证 | itsdangerous 签名 token，24h 有效 | `emailer.py`、`/ui/conflicts/{id}?t=...` |
| 10 | PC 端处理冲突 | 选择 winner_db，回写三库并标记 RESOLVED | `/conflicts/{id}/resolve`、UI |
| 11 | 移动端同步日报图形 | `/report/daily` 聚合 + Chart.js 折线图 | `/ui/report` |

> 注：本项目当前同步覆盖 INSERT/UPDATE；DELETE 同步为“已知限制”（见“局限与改进”）。

---

## 3. 系统总体架构设计

### 3.1 架构概述（文字说明）

系统由以下模块构成：

- **三套业务数据库**：MySQL、PostgreSQL、SQL Server，表结构一致。
- **数据库端触发器**：捕获业务表 INSERT/UPDATE 变更写入 `change_log`。
- **同步 worker**：轮询三库 `change_log(processed=0)`，将变更应用到其它库。
- **控制面（CONTROL_DB）**：用于存放 `conflicts`、用于报表统计、用于用户认证（可配置为任一库，默认 postgres）。
- **后端 API（FastAPI）**：提供登录/注册、冲突列表、冲突处理、报表、复杂 SQL 查询等。
- **前端页面**：Bootstrap 模板 + JS；提供冲突检测、同步报表等页面。
- **邮件链路**：Resend（第三方邮件 API） + SMTP（MailHog 捕获）双通道。
- **CloudBeaver**：数据库可视化管理工具，用于演示/验证。

### 3.2 架构图（建议插图）

（此处插入架构图：Docker 容器、数据流、控制流）

建议元素：

- 三库（MySQL/PG/MSSQL） → 触发器 → change_log  
- worker 读取 change_log → replicator 复制到其它库  
- 冲突 → 写 conflicts（CONTROL_DB）→ emailer 发邮件（含 token 链接）  
- 管理员打开链接 → UI/接口 → 选择 winner → 回写三库  
- 报表页面 → `/report/daily` → 控制库聚合数据 → Chart.js  

---

## 4. Docker 部署设计（容器类型与作用）

### 4.1 Docker Compose 服务清单（参考实现）

来自 `docker-compose.yml`（建议在报告中写成表格）：

| 容器 | 镜像/构建 | 作用 | 关键端口（宿主机→容器） |
|---|---|---|---|
| mysql | `mysql:8.0` | 业务库之一；触发器写 change_log | 13306→3306 |
| postgres | `postgres:16` | 业务库之一；默认 CONTROL_DB | 15432→5432 |
| mssql | `mcr.microsoft.com/mssql/server:2022-latest` | 业务库之一 | 14333→1433 |
| mssql-init | `mcr.microsoft.com/mssql-tools` | 初始化 SQL Server（执行 `db/mssql/01_schema.sql`） | - |
| backend | `./backend` | FastAPI 后端 + Web UI | 18000→8000 |
| worker | `./backend` | 同步 worker（轮询 change_log） | - |
| mailhog | `mailhog/mailhog` | SMTP 捕获与 Web 收件箱 | 1025/8025 |
| cloudbeaver | `dbeaver/cloudbeaver` | DB 管理可视化（演示用） | 8978→8978 |

### 4.2 关键环境变量（.env）

重点变量说明（按需粘贴）：

- `CONTROL_DB=postgres|mysql|mssql`：控制面数据库来源（认证/冲突/报表读取）
- 三库连接：`MYSQL_*`、`POSTGRES_*`、`MSSQL_*`
- 同步参数：`SYNC_MODE`、`SYNC_POLL_SECONDS`、`SYNC_BATCH_SIZE`、`SYNC_SCHEDULE_INTERVAL_SECONDS`
- 管理员注册：`ADMIN_REGISTRATION_CODE`
- 邮件：`SMTP_HOST/PORT`（MailHog）、`EMAIL_ADMIN_TO`、`RESEND_API_KEY`

### 4.3 启动/停止/重置命令（可复现实验）

- 启动：`docker compose up -d --build`
- 查看状态：`docker compose ps`
- 查看 worker 日志：`docker compose logs -f worker`
- 查看后端日志：`docker compose logs -f backend`
- 清空三库表数据（脚本）：`python backend/tools/reset_sync_data.py --db all -y`
- 彻底删除数据卷：`docker compose down -v`

### 4.4 连接信息（CloudBeaver/客户端配置，建议写清楚）

> Docker Compose 内部网络下，服务名可作为 hostname（如 `mysql`、`postgres`、`mssql`）。  
> 在宿主机使用端口映射连接（用于 CloudBeaver、Navicat、DataGrip 等）。

宿主机连接（默认）：

- MySQL：`localhost:13306`（user=`app` / password=`app_pw` / db=`syncdb`）
- PostgreSQL：`localhost:15432`（user=`app` / password=`app_pw` / db=`syncdb`）
- SQL Server：`localhost:14333`（user=`sa` / password=`YourStrong!Passw0rd` / db=`syncdb`）
- MailHog Web：`http://localhost:8025`
- CloudBeaver：`http://localhost:8978`
- 后端与 Web：`http://localhost:18000`

SQL Server 说明：

- `mssql-init` 使用 `sqlcmd -C`（信任自签证书）执行初始化脚本：`db/mssql/init.sh`。

---

## 5. 数据库设计（表结构、约束、索引、规范化）

### 5.1 E-R 模型（填写/插图）

实体与关系（参考实现）：

- **users**：系统用户（管理员）  
- **customers**：客户  
- **products**：商品  
- **orders**：订单（N:1 customers）  
- **order_items**：订单明细（N:1 orders；N:1 products）  

关系：

- customers 1 — n orders  
- orders 1 — n order_items  
- products 1 — n order_items  

（此处插入 E-R 图）

### 5.2 关系模式与主外键（参考实现）

业务表（五张）主键均为字符串 ID（VARCHAR/NVARCHAR）：

1) `users(user_id PK, username UNIQUE, password_hash, role, created_at, updated_at, updated_by_db, row_version)`  
2) `customers(customer_id PK, ...)`  
3) `products(product_id PK, ...)`  
4) `orders(order_id PK, customer_id FK->customers, ...)`  
5) `order_items(item_id PK, order_id FK->orders, product_id FK->products, ...)`  

同步元数据表：

- `change_log(change_id PK, table_name, pk_value, op_type, row_data, source_db, created_at, processed, processed_at, error)`
- `conflicts(conflict_id PK, table_name, pk_value, source_db, target_db, source_row_data, target_row_data, status, created_at, resolved_at, resolved_by, winner_db)`

### 5.3 索引设计与优化点（参考实现）

为支持订单/明细/客户聚合查询与 JOIN，建立索引：

- `orders(customer_id)` → `idx_orders_customer`
- `order_items(order_id)` → `idx_oi_order`
- `order_items(product_id)` → `idx_oi_product`

（报告可补充：为什么这些列是高频 JOIN 键、为什么能改善查询。）

### 5.4 规范化说明（填写）

建议按 1NF/2NF/3NF 写简短说明，例如：

- 1NF：各表字段原子性（价格/数量/状态等单值）。  
- 2NF：非主属性完全依赖主键（order_items 的 quantity/price 依赖 item_id）。  
- 3NF：非主属性不传递依赖（orders 不冗余 customer_name，仅保留 customer_id）。  

---

## 6. 数据库端程序对象：触发器/函数（核心）

> 本系统同步机制主要依赖 **触发器** + **变更日志表 change_log**。  
> 三库触发器逻辑一致：业务表 INSERT/UPDATE 时写入 change_log，并维护 row_version。

### 6.1 统一版本字段与来源字段

- `row_version`：行级版本号，用于冲突判定（乐观并发控制思路）。  
- `updated_by_db`：标识最后一次写入来源数据库（MYSQL/POSTGRES/MSSQL），用于 **避免同步回环**：
  - 当本库人工写入时 `updated_by_db` 为本库标签 → 触发器写入 change_log。
  - 当变更来自其它库同步写入时，会带着源库标签 → 触发器不会记录 change_log，避免无限复制。

### 6.2 MySQL 触发器（参考说明）

脚本：`db/mysql/01_schema.sql`

典型行为：

1) BEFORE INSERT：补齐 created_at/updated_at、默认 updated_by_db、默认 row_version=1  
2) BEFORE UPDATE：更新 updated_at；若 updated_by_db='MYSQL' 则 row_version=OLD+1  
3) AFTER INSERT/AFTER UPDATE：若 updated_by_db='MYSQL' 则将行数据 JSON 化写入 `change_log`（op_type=I/U）

### 6.3 PostgreSQL 触发器与函数（参考说明）

脚本：`db/postgres/01_schema.sql`

通过 plpgsql 函数封装通用逻辑：

- `trg_default_meta()`：填充默认时间、默认 updated_by_db、默认 row_version  
- `trg_bump_version()`：更新 updated_at；若 updated_by_db='POSTGRES' 则 row_version=OLD+1  
- `trg_log(...)`：写入 `change_log`（payload 使用 `json_build_object`）

### 6.4 SQL Server 触发器（参考说明）

脚本：`db/mssql/01_schema.sql`

特点：

- 使用 `inserted/deleted` 伪表判断 INSERT 还是 UPDATE，并写入 `change_log`（op_type=I/U）
- row_version 在 AFTER UPDATE 中按 updated_by_db 是否为 MSSQL 决定自增
- row_data 使用 `FOR JSON PATH, WITHOUT_ARRAY_WRAPPER` 生成 JSON

### 6.5 存储过程/游标（任务书第 3.g 条的说明与扩展点）

当前参考实现中：

- **触发器**：三库均实现（用于自动写 change_log 与维护 row_version）。  
- **函数**：PostgreSQL 使用 plpgsql 函数作为触发器逻辑复用（属于数据库端编程对象）。  
- **存储过程 / 游标**：未作为核心同步链路的必要部分（同步由触发器 + worker 完成）。

若需要在答辩中进一步体现“数据库端复杂逻辑与自动化操作”，可扩展实现：

- 归档/清理存储过程：定时归档历史订单、清理已处理 change_log。  
- 批处理过程 + 游标：对积压 change_log 分批扫描、按表/主键聚合统计（注意性能，优先集合化 SQL）。  
- 审计与告警过程：将冲突统计写入独立表并按日汇总，供报表直接读取。  

---

## 7. 同步机制实现（后端逻辑详解）

### 7.1 同步总体流程（文字 + 流程图）

1) 业务表发生 INSERT/UPDATE（某个库）  
2) 触发器将变更写入该库 `change_log(processed=0)`  
3) worker 轮询三库 change_log，取出未处理变更  
4) replicator 将变更应用到其它两库（INSERT/UPDATE）  
5) 处理完成后将源库 change_log 标记 processed=1，并记录 processed_at  

关键代码：

- worker：`backend/app/sync/worker.py`
- 复制逻辑：`backend/app/sync/replicator.py`

### 7.2 实时 / 定时 / 混合模式

配置位于 `.env`：

- `SYNC_MODE=realtime|schedule|hybrid`
- `SYNC_POLL_SECONDS`：实时轮询间隔
- `SYNC_SCHEDULE_INTERVAL_SECONDS`：定时触发间隔
- `SYNC_SCHEDULE_MAX_ROUNDS`：定时同步一轮最多跑几次（直到无新增变更）

### 7.3 跨库类型兼容（SQL Server 特殊处理）

复制时对行数据做类型归一：

- SQL Server 的 datetime 可能为 ISO 字符串 → 转 datetime 对象再写入 MySQL/PG
- SQL Server 的 BIT/布尔值 → 归一为 int

对应函数：`_normalize_row_types`（`backend/app/sync/replicator.py`）

### 7.4 表迁移/整库迁移（任务书第 1 条：支持迁移）

本项目提供“从指定源库复制数据到其它库”的接口（管理员权限）：

- 表迁移：`POST /sync/migrate/table?source_db=...&table_name=...&target=all|mysql|postgres|mssql`
- 整库迁移：`POST /sync/migrate/database?source_db=...&target=all|...`

实现思路（参考实现）：

1) 读取源库某张表所有行（`SELECT * FROM table`）。  
2) 对每个目标库逐行 upsert：不存在则 insert，存在则 update。  
3) 写入目标库时把 `updated_by_db` 标记为源库标签（如 MYSQL），避免触发器写 change_log 形成回环。  

> 说明：这属于“手工迁移/修复”的辅助能力，和触发器+worker 的实时同步互补。

---

## 8. 冲突检测与解决（后端逻辑详解）

### 8.1 冲突判定规则（当前实现）

当 worker 要把源库变更写到目标库时：

- 若目标库不存在该主键：直接插入（I/U）
- 若目标库存在：
  - 取 `existing_ver = target.row_version`
  - 取 `incoming_ver = source_row.row_version`
  - 若 `existing_ver > incoming_ver` 且 `target.updated_by_db != source_db`：
    - 记录冲突到 `conflicts`（在 CONTROL_DB）
    - 发送邮件提醒
    - 跳过本次写入
  - 否则：执行 UPDATE 覆盖

> 注意：使用严格大于（`>`），不是大于等于（`>=`）。  
> 若版本相同，则“后到者覆盖”（不会记录冲突），属于简化策略。

### 8.2 冲突记录结构

`conflicts` 保存两侧 JSON：

- `source_row_data`：源库传入行
- `target_row_data`：目标库现有行
- `status`：OPEN / RESOLVED

### 8.3 冲突邮件与 token 访问（移动端/PC）

邮件链接格式：

`http://localhost:18000/ui/conflicts/<id>?t=<token>`

- token 使用 `itsdangerous.URLSafeTimedSerializer` 生成签名，默认有效期 24h。
- UI 页面支持 token 只读查看（无需登录），满足“移动端/PC 通过链接验证身份”的要求。

对应代码：

- token 生成与校验：`backend/app/services/emailer.py`
- UI token 入口：`backend/app/main.py`（`/ui/conflicts`、`/ui/conflicts/{id}`）

### 8.4 管理员处理冲突（PC）

管理员通过接口选择胜出库（winner_db）：

- `/conflicts/{id}/resolve`：选择 MYSQL/POSTGRES/MSSQL 作为准据
- 后端将胜出行 upsert 到三库，并标记 conflicts 为 RESOLVED

（此处可贴一张处理前后截图：冲突列表、冲突详情、三库数据一致）

### 8.5 自定义修复（可选）

接口：`POST /conflicts/{id}/resolve/custom`  

用途：管理员不选择“以某个库为准”，而是提交一份 JSON 作为最终行数据，后端会把该行 upsert 到三库并标记冲突已解决。

---

## 9. 用户管理与权限（后端逻辑详解）

### 9.1 认证方式

- 登录：`POST /auth/login`（从 CONTROL_DB 的 users 表校验）
- 注册：`POST /auth/register`（需要注册码 `ADMIN_REGISTRATION_CODE`）
- Token：JWT（HS256），前端保存到 localStorage，后续请求通过 `Authorization: Bearer ...`

### 9.2 权限控制

- 普通接口：需要登录 token（`/me`、查询等）
- 管理员接口：要求 `is_admin=true`（例如冲突处理）

核心代码：

- `backend/app/auth.py`
- `backend/app/main.py`

### 9.3 默认管理员与注册机制（参考实现说明）

- 服务启动时会执行 `ensure_admin_seeded()`：确保三库都存在默认管理员账号（避免某库被清空后无法通过同步补齐）。  
- 注册接口 `/auth/register` 必须提供注册验证码（`.env` 的 `ADMIN_REGISTRATION_CODE`），用于控制“谁能注册管理员账号”。  

> 演示时建议：答辩前更换 `.env` 中的 `ADMIN_REGISTRATION_CODE`，并避免在 UI 明示默认值。

---

## 10. 复杂 SQL 查询与优化（任务书第 5 条）

### 10.1 查询需求（填写）

示例：查询近 N 天消费额最高的 Top-K 客户（customer + orders + order_items）。

### 10.2 SQL 语句（参考实现）

后端实现：`/queries/top-customers` 与 `/ui/query`。

逻辑：

- 子查询：按 customer_id 聚合 SUM(oi.quantity * oi.price)
- 外层 JOIN customers 获取客户信息
- ORDER BY total_amount DESC
- LIMIT / TOP 限制返回行数

### 10.3 索引与优化点（说明）

- `orders.updated_at`（用于时间过滤，若扩展可加索引）
- `orders.customer_id`（JOIN + GROUP BY）
- `order_items.order_id`（JOIN）

（可补充：Explain 分析截图/输出）

---

## 11. 同步报表与可视化（任务书第 11 条）

### 11.1 报表数据来源

后端接口：`GET /report/daily?days=14`（需要登录 token）

- `change_log`：按 processed_at 聚合每日同步条数
- `conflicts`：按 created_at 聚合每日冲突条数

### 11.2 前端展示

- 页面：`/ui/report`
- 图表：Chart.js 折线图

（此处放报表截图）

### 11.3 常见问题：报表为空

若报表页面显示为空，优先检查：

1) 是否携带登录 token：`/report/daily` 需要 `Authorization: Bearer ...`，未登录会 401。  
2) 控制库（CONTROL_DB）中是否存在统计数据：  
   - `change_log`：必须 `processed=1` 且 `processed_at` 非空才会计入“同步变更”  
   - `conflicts`：按 `created_at` 聚合  
3) worker 是否运行并处理了变更：`docker compose logs -f worker`  

---

## 12. 实验步骤与运行实例（建议直接照此演示）

> 可直接引用 `TEST_PLAN.md` 的步骤，并在此处补充“截图/日志/SQL 输出”。

### 12.1 导入数据与触发器验证

1) 启动容器：`docker compose up -d --build`
2) CloudBeaver 连接三库并确认触发器存在  
3) 导入示例数据：执行根目录 `database_table` 或调用 `/demo/import-database-table`

### 12.2 同步验证（无冲突）

在 MySQL 更新 products.stock，观察 PG/MSSQL 同步变化；并观察 worker 日志与 change_log.processed。

### 12.3 冲突制造与处理

构造 row_version 不一致，触发 conflicts；确认邮件到达（MailHog/真实邮箱）；管理员处理并回写三库一致。

### 12.4 日报验证

进入 `/ui/report`，查看近 14 天同步变更与冲突折线图。

---

## 13. 安全性、可靠性与工程化（填写）

可从以下角度写：

- 密码安全：bcrypt 哈希，不存明文
- Token 安全：JWT + 过期时间；冲突链接 token 24h
- 异常处理：worker 处理失败不 mark processed，可重试
- 数据一致性：触发器 + 版本号；冲突不覆盖，记录并人工裁决
- Docker 化部署：一键启动、环境隔离、便于演示
- Git 版本管理：提交记录、README、脚本、报告与 PPT

### 13.1 第三方接口调用说明（任务书要求）

本项目邮件通知链路体现第三方接口调用：

- 优先/并行渠道：Resend 邮件 API（`.env` 的 `RESEND_API_KEY`）  
- SMTP 渠道：MailHog（开发环境收件箱，便于答辩演示）

---

## 14. 运维与数据管理（可选加分项）

### 14.1 数据导入/导出

- 示例数据导入：根目录 `database_table`（可在 CloudBeaver 直接执行）  
- 后端导入接口：`POST /demo/import-database-table?db=all`（按库导入）  

### 14.2 备份与恢复（建议写出可执行命令）

（填写你演示/提交时采用的方案，以下为示例）

- MySQL 备份（容器内执行）：  
  `docker compose exec mysql mysqldump -uapp -papp_pw syncdb > mysql_syncdb.sql`
- PostgreSQL 备份：  
  `docker compose exec postgres pg_dump -U app -d syncdb > pg_syncdb.sql`
- SQL Server 备份：  
  可使用 `sqlcmd` 执行 `BACKUP DATABASE`（或使用容器卷备份方式）

---

## 15. 局限与改进方向（建议必写）

参考实现当前局限（可按实际改动）：

1) **DELETE 未同步**：触发器未记录删除，复制端也未处理 op_type='D'。  
2) **同版本并发写**：当 row_version 相同不会记冲突，后到覆盖（可改为 >= 判冲突或引入时间戳/全局版本）。  
3) **一致性与事务边界**：跨库复制为 best-effort；可增强为幂等重试、死信队列、补偿事务。  
4) **安全加固**：注册流程、权限分级、审计日志、密钥轮换、CSRF 防护等。  
5) **性能优化**：批处理、索引、分区、监控指标（延迟、积压、冲突率）。  

---

## 16. 附录

### 附录 A：关键文件索引（建议列出）

- `docker-compose.yml`：容器编排
- `.env`：环境变量
- `db/*/01_schema.sql`：三库表结构、索引、触发器
- `backend/app/sync/worker.py`：实时/定时同步 worker
- `backend/app/sync/replicator.py`：复制与冲突判定核心
- `backend/app/services/emailer.py`：邮件与 token
- `backend/app/main.py`：API 路由与页面渲染
- `TEST_PLAN.md`：手工验证用例

### 附录 B：演示截图清单（建议）

- Docker 容器运行截图（`docker compose ps`）
- CloudBeaver 三库连接与表结构截图
- worker 日志同步截图
- 冲突列表/详情截图
- MailHog 收到邮件截图（含 token 链接）
- 同步报表折线图截图
